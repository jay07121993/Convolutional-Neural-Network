# Before running this code, visit my data preporcessing file which makes you understand how to pre-process data for specific model. 

## necssary import libraries
'''
import pandas as pd
import numpy as np
import os
from sklearn import preprocessing
from sklearn.model_selection import StratifiedKFold,KFold,ShuffleSplit
import cntk as c
import matplotlib.pyplot as plt
from keras import backend as c
from keras.models import Sequential
from keras.layers.core import Dense, Dropout, Activation, Flatten
from keras.layers.convolutional import Conv1D, MaxPooling1D
from keras.optimizers import SGD, Adam
from keras import regularizers
'''
# load csv file into system.
'''
x_train= np.loadtxt(filepath, delimiter=',', dtype='float32')
print(x_train.shape)
'''
# seperate features and labels from the loaded file
'''
a= x_train[:,0:50]
b= x_train[:,50:52]
print(a.shape, b.shape)
'''

# CNN takes input in a specific format so we should reshape accordingly. Here I have used CNN 1D layer so I changes the input accordingly.
'''
a=a.reshape(144765,5,10)
'''

# From sklearn I have used the method shufflesplit. This method creates train and test dataset from the loaded dataset with shuffle.
'''
sh= ShuffleSplit(n_splits=5, test_size=0.25, train_size=None)
'''
# Input dimension is tell the dense layes what type of input to expect.
input_dimension= 50
'''

# Compiling , Fitting and validating model based on the bins created by shuffle split.
'''
for train, test in sh.split(a,b):
    print("TRAIN:", train, "TEST:", test)
    model= Sequential()
    # If CNN is the first layer of model then we have to specify input shape to the layer. That is why we reshaped input.
    model.add(Conv1D(strides=1, input_shape=(5, 10), padding="same", activation="tanh", filters=32, kernel_size=2))
    # Reducing the feature map generated by CNN layer by maxpooling. We can also use avg pooling.
    pool1= model.add(MaxPooling1D(pool_size=2, strides=None, padding='same'))
    model.add(Conv1D(strides=1, padding="same", activation="tanh", filters=16, kernel_size=1))
    model.add(Dropout(0.2))
    model.add(Conv1D(strides=1, padding="same", activation="tanh", filters=8, kernel_size=1))
    pool2= model.add(MaxPooling1D(pool_size=2, strides=None, padding='same'))
    # before sending the values to fully connected layer we have to flatten the output of CNN layer to 1D array.
    model.add(Flatten())
    
    # Fully connected layer.
    model.add(Dense(128, input_dim=input_dimension, activation='relu',kernel_regularizer=regularizers.l2(0.01)))
    model.add(Dropout(0.2))
    model.add(Dense(2, activation='softmax'))
    adam=Adam(lr=0.0001, beta_1=0.9, beta_2=0.999, epsilon=None, decay=0.0, amsgrad=False)
    model.compile(loss='binary_crossentropy', optimizer=adam, metrics=['acc'])
    model.fit(a[train], b[train], epochs=5, batch_size=None)
    predict= model.predict(a[test])
    scores = model.evaluate(a[test], b[test])
    print("%s: %.2f%%" % (model.metrics_names[1], scores[1]*100))
'''
